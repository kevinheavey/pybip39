use bip39::{
    Language as LanguageOriginal, Mnemonic as MnemonicOriginal,
    MnemonicType as MnemonicTypeOriginal, Seed as SeedOriginal,
};
use pyo3::prelude::*;

fn resolve_language(lang: &Language) -> LanguageOriginal {
    match lang {
        Language::English => LanguageOriginal::English,
        Language::ChineseSimplified => LanguageOriginal::ChineseSimplified,
        Language::ChineseTraditional => LanguageOriginal::ChineseTraditional,
        Language::French => LanguageOriginal::French,
        Language::Italian => LanguageOriginal::Italian,
        Language::Japanese => LanguageOriginal::Japanese,
        Language::Korean => LanguageOriginal::Korean,
        Language::Spanish => LanguageOriginal::Spanish,
    }
}

/// The primary type in this library - most tasks require creating or using one.
///
/// To create a *new* ``Mnemonic`` from a randomly generated key, call ``Mnemonic()``.
///
/// To get a ``Mnemonic`` instance for an existing mnemonic phrase, including
/// those generated by other software or hardware wallets, use :meth:`from_phrase`.
///
/// You can get the HD wallet seed from a ``Mnemonic`` by instantiating :class:`Seed`.
/// From there you can either get the raw byte value with ``bytes(seed)``, or the hex
/// representation with :meth:`Seed.hex`.
///
/// You can also get the original entropy value back from a ``Mnemonic`` with :attr:`entropy`,
/// but beware that the entropy value is **not the same thing** as an HD wallet seed, and should
/// *never* be used that way.
///
/// Args:
///     mtype (MnemonicType, optional): The number of words in the seed phrase. Defaults to :attr:`MnemonicType.Words12`.
///     language (Language, optional): The language of the seed phrase. Defaults to :attr:`Language.English`.
///
/// Example:
///      >>> from pybip39 import Mnemonic, MnemonicType, Language
///      >>> mnemonic = Mnemonic(MnemonicType.Words12, Language.English)
///      >>> phrase = mnemonic.phrase
///      >>> len(phrase.split(" "))
///      12
#[pyclass]
#[pyo3(text_signature = "(mtype, language)")]
struct Mnemonic(pub MnemonicOriginal);

#[pymethods]
impl Mnemonic {
    #[new]
    #[args(mtype = "MnemonicType::Words12", language = "Language::English")]
    pub fn new(mtype: MnemonicType, language: Language) -> Self {
        let mtype_original = match mtype {
            MnemonicType::Words12 => MnemonicTypeOriginal::Words12,
            MnemonicType::Words15 => MnemonicTypeOriginal::Words15,
            MnemonicType::Words18 => MnemonicTypeOriginal::Words18,
            MnemonicType::Words21 => MnemonicTypeOriginal::Words21,
            MnemonicType::Words24 => MnemonicTypeOriginal::Words24,
        };
        let resolved_language = resolve_language(&language);
        Self(MnemonicOriginal::new(mtype_original, resolved_language))
    }
    /// Create a :class:`Mnemonic` from pre-generated entropy.
    ///
    /// Args:
    ///     entropy (bytes): The entropy value of the mnemonic phrase.
    ///     language (Language, optional): The language of the seed phrase. Defaults to :attr:`Language.English`.
    ///
    /// Returns:
    ///     Mnemonic: The mnemonic object.
    ///
    /// Example:
    ///      >>> from pybip39 import Mnemonic, MnemonicType, Language
    ///      >>> entropy = bytes([0x33, 0xE4, 0x6B, 0xB1, 0x3A, 0x74, 0x6E, 0xA4, 0x1C, 0xDD, 0xE4, 0x5C, 0x90, 0x84, 0x6A, 0x79])
    ///      >>> mnemonic = Mnemonic.from_entropy(entropy, Language.English)
    ///      >>> mnemonic.phrase
    ///      'crop cash unable insane eight faith inflict route frame loud box vibrant'
    ///      >>> mnemonic.hex()
    ///      '33e46bb13a746ea41cdde45c90846a79'
    #[staticmethod]
    #[args(language = "Language::English")]
    #[pyo3(text_signature = "(entropy, language)")]
    pub fn from_entropy(entropy: &[u8], language: Language) -> PyResult<Self> {
        let lang = resolve_language(&language);
        let underlying = MnemonicOriginal::from_entropy(entropy, lang)?;
        Ok(Self(underlying))
    }
    /// Create a :class:`Mnemonic` from an existing mnemonic phrase.
    ///
    /// The phrase supplied will be checked for word length and validated according to the checksum
    /// specified in BIP0039
    ///
    /// Args:
    ///     phrase (str): The seed phrase.
    ///     language (Language, optional): The language of the seed phrase. Defaults to :attr:`Language.English`.
    ///
    /// Returns:
    ///     Mnemonic: The mnemonic object.
    ///
    /// Example:
    ///     >>> from pybip39 import Mnemonic, Language
    ///     >>> phrase = "park remain person kitchen mule spell knee armed position rail grid ankle"
    ///     >>> mnemonic = Mnemonic.from_phrase(phrase, Language.English)
    ///     >>> mnemonic.phrase
    ///     'park remain person kitchen mule spell knee armed position rail grid ankle'
    #[staticmethod]
    #[args(language = "Language::English")]
    #[pyo3(text_signature = "(phrase, language)")]
    pub fn from_phrase(phrase: &str, language: Language) -> PyResult<Self> {
        let lang = resolve_language(&language);
        let underlying = MnemonicOriginal::from_phrase(phrase, lang)?;
        Ok(Self(underlying))
    }

    /// Validate a mnemonic phrase.
    ///
    /// The phrase supplied will be checked for word length and validated according to the checksum
    /// specified in BIP0039.
    ///
    /// Returns ``None`` if phrase is valid.
    ///
    /// Args:
    ///     phrase (str): The phrase to validate.
    ///     language (Language, optional): The language of the phrase. Defaults to :attr:`Language.English`.
    ///
    /// Raises:
    ///      RuntimeError: If validation fails.
    ///
    /// Example:
    ///      >>> from pybip39 import Mnemonic, Language
    ///      >>> test_mnemonic = "park remain person kitchen mule spell knee armed position rail grid ankle"
    ///      >>> Mnemonic.validate(test_mnemonic, Language.English)
    ///      >>> Mnemonic.validate(test_mnemonic, Language.Spanish)
    ///      Traceback (most recent call last):
    ///        File "<stdin>", line 1, in <module>
    ///      RuntimeError: invalid word in phrase
    #[staticmethod]
    #[args(language = "Language::English")]
    #[pyo3(text_signature = "(phrase, language)")]
    pub fn validate(phrase: &str, language: Language) -> PyResult<()> {
        let lang = resolve_language(&language);
        Ok(MnemonicOriginal::validate(phrase, lang)?)
    }
    /// bytes: The original entropy value of the mnemonic phrase.
    ///
    /// Example:
    ///     >>> from pybip39 import Mnemonic
    ///     >>> phrase = "park remain person kitchen mule spell knee armed position rail grid ankle"
    ///     >>> mnemonic = Mnemonic.from_phrase(phrase)
    ///     >>> mnemonic.entropy
    ///     b'\xa0V\xb2\x8d=\x89\x15\xa2^\xe0^\xa8v\x1d\x99\x84'
    ///
    /// Note:
    ///     You shouldn't use the generated entropy as secrets, for that generate a new `Seed` from the `Mnemonic`.
    #[getter]
    pub fn entropy(&self) -> &[u8] {
        self.0.entropy()
    }

    /// str: The mnemonic phrase.
    #[getter]
    pub fn phrase(&self) -> &str {
        self.0.phrase()
    }

    /// Get the hex-formatted mnemonic.
    ///
    /// Returns:
    ///      str: The hex-formatted mnemonic.
    pub fn hex(&self) -> String {
        format!("{:x}", self.0)
    }

    pub fn __str__(&self) -> &str {
        self.phrase()
    }

    pub fn __bytes__(&self) -> &[u8] {
        self.entropy()
    }
}

/// The supported languages for seed phrases.
#[pyclass]
#[derive(Clone)]
enum Language {
    English,
    ChineseSimplified,
    ChineseTraditional,
    French,
    Italian,
    Japanese,
    Korean,
    Spanish,
}

/// The supported word counts for seed phrases.
#[pyclass]
#[derive(Clone)]
pub enum MnemonicType {
    Words12,
    Words15,
    Words18,
    Words21,
    Words24,
}

/// The secret value used to derive HD wallet addresses from a :class:`Mnemonic` phrase.
///
/// Because it is not possible to create a :class:`Mnemonic` instance that is invalid, it is
/// therefore impossible to have a ``Seed`` instance that is invalid. This guarantees that only
/// a valid, intact mnemonic phrase can be used to derive HD wallet addresses.
///
/// To get the raw byte value use ``bytes(seed)``. These can be used to derive
/// HD wallet addresses using another crate (deriving HD wallet addresses is outside the scope of this
/// crate and the BIP39 standard).
///
/// Args:
///      mnemonic (Mnemonic): The mnemonic to generate the seed from.
///      password (str): The seed password.
#[pyclass]
struct Seed(pub SeedOriginal);

#[pymethods]
impl Seed {
    #[new]
    pub fn new(mnemonic: &Mnemonic, password: &str) -> Self {
        Self(SeedOriginal::new(&mnemonic.0, password))
    }

    pub fn __bytes__(&self) -> &[u8] {
        self.0.as_bytes()
    }

    /// Get the hex-formatted seed.
    ///
    /// Returns:
    ///      str: The hex-formatted seed.
    pub fn hex(&self) -> String {
        format!("{:x}", self.0)
    }
}

#[pymodule]
fn pybip39(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<Mnemonic>()?;
    m.add_class::<Language>()?;
    m.add_class::<Seed>()?;
    m.add_class::<MnemonicType>()?;
    Ok(())
}
